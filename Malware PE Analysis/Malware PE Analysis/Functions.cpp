/*
* Project: Malware PE Analysis
* File: Functions.cpp
*
* Author: Matthew Todd Geiger
*
* Time: 3:03
*
* Brief: This file contains the diagnosing source code
*/

#define _CRT_SECURE_NO_WARNINGS

#include "defs.h"

unsigned long dwFPos = NULL;

DWORD dwSectionDataPointer[24];
DWORD dwSectionRVA[24];
DWORD dwSectionSizeArray[24];

DWORD dwSectionTotalSize = NULL;
DWORD dwFileSize = NULL;

int dwTest = 0;

bool ResourceDirectory(DWORD, DWORD);
bool SectionHeaderSelector(DWORD_PTR, DWORD, DWORD);
bool ImportDirectory(DWORD, DWORD);
bool BoundImportDirectory(DWORD, DWORD);
bool DelayImportDirectory(DWORD, DWORD);
bool BaseRelocationDirectory(DWORD, DWORD);
bool TLSDirectory(DWORD, DWORD);

unsigned long RvaToOffset(DWORD, DWORD, DWORD);

PIMAGE_DOS_HEADER DosHeader(DWORD_PTR pBuffer) {
	PIMAGE_DOS_HEADER pIDH = NULL;
	PIMAGE_NT_HEADERS pINH = NULL;

	printf("--! ANALYZING DOS HEADER !--\n");

	pIDH = (PIMAGE_DOS_HEADER)pBuffer;

	// Check MZ Exec Signature
	if (pIDH->e_magic != IMAGE_DOS_SIGNATURE) {
		fprintf(stderr, "[?] MZ Value Not Found!\n");
		return 0;
	}

	printf("[!] e_magic value seems intact! e_magic: 0x%X\n", pIDH->e_magic);

	// Check e_lfanew
	pINH = (PIMAGE_NT_HEADERS)(pBuffer + pIDH->e_lfanew);
	if (pINH->FileHeader.Machine)
		printf("[!] e_lfanew value seems to be valid! e_lfanew: 0x%X\n", pIDH->e_lfanew);
	else {
		fprintf(stderr, "[?] e_lfanew value is invalid!\n");
		return 0;
	}

	return pIDH;
}

PIMAGE_NT_HEADERS NtHeaders(DWORD_PTR pBase) {
	PIMAGE_NT_HEADERS pINH = (PIMAGE_NT_HEADERS)pBase;

	printf("\n--! ANALYZING \"NT HEADERS\" STRUCTURE !--\n");

	// Check PE Signature
	if (pINH->Signature != IMAGE_NT_SIGNATURE) {
		fprintf(stderr, "[?] The \"NT HEADERS\" Contains an invalid signature...\n");
		return 0;
	}

	printf("[!] PE Signature Recognized! The 4-Byte ASCII Signature is \"PE\\0\\0\"\n");

	return pINH;
}

PIMAGE_FILE_HEADER FileHeader(DWORD_PTR pBase) {
	PIMAGE_FILE_HEADER pIFH;

	printf("\n--! ANALYZING FILE HEADER !--\n");

	pIFH = (PIMAGE_FILE_HEADER)pBase;

	// Check Assembler Format
	switch (pIFH->Machine) {
	case IMAGE_FILE_MACHINE_I386:
		printf("[!] The FILE HEADER Contains a 32-Bit Machine Signature: PE32 Binary\n");
		break;

	case IMAGE_FILE_MACHINE_AMD64:
		printf("[!] The FILE HEADER Contains a 64-Bit Machine Signature: PE32+ Binary\n");
		break;

	default:
		printf("[!] The FILE HEADER Contains an invalid or esotaric machine signature: 0x%X\n", pIFH->Machine);
		break;
	}

	// Check Epoch Time
	if (!pIFH->TimeDateStamp)
		fprintf(stderr, "[?] The File Header Contains an Invalid Time/Date Stamp...\n");

	printf("[!] The FILE HEADER's Time Since Epoch(sec): %d\n", pIFH->TimeDateStamp);

	// Check Number of Sections
	if (!pIFH->NumberOfSections) {
		fprintf(stderr, "[?] The File Header Contains an Invalid Number Of Sections...\n");
	}
	else {
		printf("[!] The FILE HEADER's Number of Sections: %d\n", pIFH->NumberOfSections);
	}

	// Compare characteristics
	if (pIFH->Characteristics) {
		printf("[SS] The FILE HEADER's Characteristics \\/\n");

		if (pIFH->Characteristics & IMAGE_FILE_32BIT_MACHINE)
			printf("\t[S] IMAGE_FILE_32BIT_MACHINE - 32-Bit Flag\n");
		if (pIFH->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)
			printf("\t[S] IMAGE_FILE_EXECUTABLE_IMAGE - File is Executable\n");
		if (pIFH->Characteristics & IMAGE_FILE_LINE_NUMS_STRIPPED)
			printf("\t[S] IMAGE_FILE_LINE_NUMS_STRIPPED - The Line Numbers Have Been Stripped From File\n");
		if (pIFH->Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE)
			printf("\t[S] IMAGE_FILE LARGE_ADDRESS_AWARE - File Handles > 2gb Addresses\n");
		if (pIFH->Characteristics & IMAGE_FILE_SYSTEM)
			printf("\t[S] IMAGE_FILE_SYSTEM - System Executable\n");
		if (pIFH->Characteristics & IMAGE_FILE_DLL)
			printf("\t[S] IMAGE_FILE_DLL - File is a DLL\n");
		if (!(pIFH->Characteristics & (IMAGE_FILE_32BIT_MACHINE | IMAGE_FILE_EXECUTABLE_IMAGE |
			IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LARGE_ADDRESS_AWARE |
			IMAGE_FILE_SYSTEM | IMAGE_FILE_DLL)))
			fprintf(stderr, "\t[S?] The Characteristics variable contains a value, but does not hold proper values\n");
		if (pIFH->Characteristics & (IMAGE_FILE_DLL | IMAGE_FILE_32BIT_MACHINE | IMAGE_FILE_EXECUTABLE_IMAGE))
			printf("\t[S?] Seems to be a Standard DLL File\n");

		if (!(pIFH->Characteristics & IMAGE_FILE_32BIT_MACHINE)) {
			fprintf(stderr, "[?] This Program can Only Scan 32-Bit Files!\n");
			return false;
		}
	}
	else
		fprintf(stderr, "[?] The File Header Contains an Invalid Characteristics Value...\n");

	// Find Optional Header Size
	if (!pIFH->SizeOfOptionalHeader) {
		fprintf(stderr, "[?] The File Header Contains an Invalid Optional Header Size...\n");
	}
	else {
		printf("[!] The FILE HEADER's size of optional header variable: 0x%X\n", pIFH->SizeOfOptionalHeader);
	}

	return pIFH;
}

PIMAGE_OPTIONAL_HEADER OptionalHeader(DWORD_PTR pBase, DWORD_PTR pBuffer, DWORD ddwFileSize) {
	PIMAGE_OPTIONAL_HEADER pIOH = (PIMAGE_OPTIONAL_HEADER)pBase;
	DWORD dwFileOffset = NULL;

	printf("\n--! OPTIONAL HEADER !--\n");

	// Testing Magic Number
	if (pIOH->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC && pIOH->Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		fprintf(stderr, "[?] The Optional Header's Magic Value Does Not Match 32 or 64 Bit Definitions\n");
	}
	else if (pIOH->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
		printf("[!] The Optional Header's Magic Value Matches a 32 Bit Signature\n");
	}
	else if (pIOH->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		printf("[!] The Optional Header's Magic Value Matches a 64 Bit Signature\n");
	}

	if (!pIOH->AddressOfEntryPoint) {
		fprintf(stderr, "[?] The Optional Header's Entry Point RVA is invalid\n");
	}

	printf("[!] The Optional Header's Entry Point RVA: 0x%X\n", pIOH->AddressOfEntryPoint);

	if (!pIOH->SizeOfImage) {
		fprintf(stderr, "[?] The Optional Header's Size of Image Variable is Invalid");
	}

	printf("[!] The Optional Header's Size of Image vs File Size: %d/%d Bytes\n", pIOH->SizeOfImage, ddwFileSize);
	dwFileSize = ddwFileSize;

	if (!pIOH->SectionAlignment || !pIOH->FileAlignment) {
		fprintf(stderr, "[?] The Optional Header's Section Alignment or File Alignment is Invalid\n");
	}

	printf("[!] The Optional Header's Section Alignment(Buffer) and File Alignment(Section Chunks): 0x%x & 0x%x \n", pIOH->SectionAlignment, pIOH->FileAlignment);

	if (!pIOH->ImageBase) {
		fprintf(stderr, "[?] The Optional Header's Image Base is Invalid\n");
	}

	printf("[!] The Optional Header's Image Base: 0x%x\n", pIOH->ImageBase);

	// Dll Characteristics
	if (pIOH->DllCharacteristics) {
		printf("[SS] The Optional Header's DLL Characteristics \\/\n");

		if (pIOH->DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)
			printf("\t[S] IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE - The DLL Can Move\n");
		if (pIOH->DllCharacteristics & IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY)
			printf("\t[S] IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY - Force Signed HASH Check\n");
		if (pIOH->DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
			printf("\t[S] IMAGE_DLLCHARACTERISTICS_NX_COMPAT - Compatible with DEP\n");
		if (pIOH->DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_SEH)
			printf("\t[S] IMAGE_DLLCHARACTERISTICS_NO_SEH - No Structered Exception Handling\n");
		if (!(pIOH->DllCharacteristics &
			(IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE | IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY |
				IMAGE_DLLCHARACTERISTICS_NX_COMPAT | IMAGE_DLLCHARACTERISTICS_NO_SEH)))
			fprintf(stderr, "\t[S?] This PE File Lacks Common Security Characteristics (ex: DEP, ASLR, SEH)\n");
	}
	else {
		fprintf(stderr, "[?] The Optional Header's DLL Characteristics Variable is NULL\n");
	}

	for (int i = 0; true; i++) {
		if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress <= dwSectionRVA[i]) {
			dwTest = (i - 1);
			if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress == dwSectionRVA[i])
				dwTest++;
			break;
		}
	}

	printf("\n");
	printf("[!] Import Directory Virtual Address %d | 0x%X\n", pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
		pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

	if (dwTest > -1 && pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) {
		dwFileOffset = RvaToOffset(pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		dwFPos = dwFileOffset;
		printf("[!] Import Directory File Offset: %d | 0x%X\n", dwFileOffset, dwFileOffset);

		if (!ImportDirectory(dwFileOffset, pBuffer)) {
			fprintf(stderr, "[?] The Optional Header's Import Directory is Invalid\n");
		}

	}
	else {
		printf("[?] Failed To Find Import Directory...\n");
	}

	for (int i = 0; true; i++) {
		if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress <= dwSectionRVA[i]) {
			dwTest = (i - 1);
			if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress == dwSectionRVA[i])
				dwTest++;
			break;
		}
	}

	printf("\n");
	printf("[!] Bound Import Directory Virtual Address %d | 0x%X\n", pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress,
		pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress);

	if (dwTest > -1 && pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress) {
		dwFileOffset = RvaToOffset(pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		dwFPos = dwFileOffset;
		printf("[!] Bound Import Directory File Offset: %d | 0x%X\n", dwFileOffset, dwFileOffset);

		if (!DelayImportDirectory(dwFileOffset, pBuffer)) {
			fprintf(stderr, "\n[?] The Optional Header's Bound Import Directory is Invalid\n");
		}

	}
	else {
		printf("[?] Failed To Find Bound Import Directory...\n");
	}

	for (int i = 0; true; i++) {
		if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress <= dwSectionRVA[i]) {
			dwTest = (i - 1);
			if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress == dwSectionRVA[i])
				dwTest++;
			break;
		}
	}

	printf("\n");
	printf("[!] Delay Import Directory Virtual Address %d | 0x%X\n", pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress,
		pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress);

	if (dwTest > -1 && pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress) {
		dwFileOffset = RvaToOffset(pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		dwFPos = dwFileOffset;
		printf("[!] Delay Import Directory File Offset: %d | 0x%X\n", dwFileOffset, dwFileOffset);

		if (!BoundImportDirectory(dwFileOffset, pBuffer)) {
			fprintf(stderr, "\n[?] The Optional Header's Delay Import Directory is Invalid\n");
		}

	}
	else {
		printf("[?] Failed To Find Delay Import Directory...\n");
	}

	for (int i = 0; true; i++) {
		if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress <= dwSectionRVA[i]) {
			dwTest = (i - 1);
			if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress == dwSectionRVA[i])
				dwTest++;
			break;
		}
	}

	printf("\n");
	printf("[!] Base Relocation Directory Virtual Address %d | 0x%X\n", pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
		pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

	if (dwTest > -1 && pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress) {
		dwFileOffset = RvaToOffset(pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		dwFPos = dwFileOffset;
		printf("[!] Base Relocation Directory File Offset: %d | 0x%X Inside Section %d\n", dwFileOffset, dwFileOffset, dwTest);

		if (!BaseRelocationDirectory(dwFileOffset, pBuffer)) {
			fprintf(stderr, "\n[?] The Optional Header's Base Relocation Directory is Invalid\n");
		}

	}
	else {
		printf("[?] Failed To Find Base Relocation Directory...\n");
	}

	for (int i = 0; true; i++) {
		if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress <= dwSectionRVA[i]) {
			dwTest = (i - 1);
			if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress == dwSectionRVA[i])
				dwTest++;
			break;
		}
	}

	printf("\n");
	printf("[!] TLS Directory Virtual Address %d | 0x%X\n", pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress,
		pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);

	if (dwTest > -1 && pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress && pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size) {
		dwFileOffset = RvaToOffset(pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		dwFPos = pIOH->ImageBase;
		printf("[!] TLS Directory File Offset: %d | 0x%X Inside Section %d\n", dwFileOffset, dwFileOffset, dwTest);

		if (!TLSDirectory(dwFileOffset, pBuffer)) {
			fprintf(stderr, "\n[?] The Optional Header's TLS Directory is Invalid\n");
		}

	}
	else {
		printf("[?] Failed To Find TLS Directory...\n");
	}

	for (int i = 0; true; i++) {
		if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress <= dwSectionRVA[i]) {
			dwTest = (i - 1);
			if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress == dwSectionRVA[i])
				dwTest++;
			break;
		}
	}

	printf("\n");
	printf("[!] Resource Directory Virtual Address %d | 0x%X\n", pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress,
		pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress);

	if (dwTest > -1 && pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress && pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size) {
		dwFileOffset = RvaToOffset(pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		dwFPos = pIOH->ImageBase;
		printf("[!] Resource Directory File Offset: %d | 0x%X Inside Section %d\n", dwFileOffset, dwFileOffset, dwTest);

		if (!ResourceDirectory(dwFileOffset, pBuffer)) {
			fprintf(stderr, "\n[?] The Optional Header's Resource Directory is Invalid\n");
		}

	}
	else {
		printf("[?] Failed To Find Resource Directory...\n");
	}

	return pIOH;
}

PIMAGE_SECTION_HEADER SectionHeader(DWORD_PTR pBase, DWORD dwSections, DWORD dwFileAlignment) {
	PIMAGE_SECTION_HEADER pISH = (PIMAGE_SECTION_HEADER)pBase;

	printf("\n--! SECTION HEADER !--\n");

	for (DWORD dwCount = 0; dwCount < dwSections; dwCount++) {
		DWORD_PTR pNewSection = (DWORD_PTR)pISH;

		if (!SectionHeaderSelector(pNewSection, dwCount, dwFileAlignment)) {
			fprintf(stderr, "[?] Failed to Read Section %d\n", dwCount);
			return 0;
		}

		printf("\n[!] Total Size of all Sections: %d | 0x%X", dwSectionTotalSize);

		pISH++;
	}

	return pISH;
}

/*PRIVATE FUNCTIONS*/

bool SectionHeaderSelector(DWORD_PTR pBase, DWORD dwCount, DWORD dwFileAlignment) {
	PIMAGE_SECTION_HEADER pISH = (PIMAGE_SECTION_HEADER)pBase;

	char szName[9];

	printf("\nSECTION %d\n", dwCount);

	// "strcpy" for possibly NON-NULL Terminated Strings
	for (DWORD i = 0; i < 9; i++) {
		if (!((BYTE)pISH->Name[i])) {
			szName[i] = 0;
			break;
		}

		szName[i] = (char)pISH->Name[i];
	}

	if (strlen(szName) >= 9)
		szName[8] = 0;

	if (!((int)szName[0])) {
		fprintf(stderr, "[?] The Section Header's Name is Invalid or Miss Read\n");
		//return false;
	}

	printf("[!] The Section Header's Name is: %s\n", szName);

	if (!pISH->Misc.VirtualSize) {
		fprintf(stderr, "[?] Section Header Misc.VirtualSize is Invalid\n");
	}

	printf("[!] Section Header Misc.VirtualSize: 0x%X | %d\n", pISH->Misc.VirtualSize, pISH->Misc.VirtualSize);

	if (!pISH->SizeOfRawData) {
		fprintf(stderr, "[?] Section Header Size of Raw Data is Invalid for an Executable\n");
	}

	if (pISH->Misc.VirtualSize < dwFileAlignment) {
		printf("[?] Section Header Misc.VirtualSize is Smaller than the Required Length of %d\n", dwFileAlignment);
	}

	printf("[!] Section Header Size of Raw Data: 0x%X | %d\n", pISH->SizeOfRawData, pISH->SizeOfRawData);

	if (pISH->Misc.VirtualSize > pISH->SizeOfRawData) {
		printf("[?] Section Header Size of Raw Data is Less than the Virtual Size\n");
	}

	if (!pISH->PointerToRawData) {
		fprintf(stderr, "[?] Section Header Pointer to Raw Data is Invalid for an Executable\n");
	}

	printf("[!] Section Header Pointer to Raw Data: 0x%X\n", pISH->PointerToRawData);

	printf("[!] Section Header Virtual Address: %d | 0x%X\n", pISH->VirtualAddress, pISH->VirtualAddress);

	dwSectionDataPointer[dwCount] = pISH->PointerToRawData;
	dwSectionRVA[dwCount] = pISH->VirtualAddress;
	dwSectionSizeArray[dwCount] = pISH->SizeOfRawData;

	if (pISH->Characteristics) {
		printf("[SS] Section Header's Characteristics\\/\n");

		if (!(pISH->Characteristics & (IMAGE_SCN_CNT_CODE | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_UNINITIALIZED_DATA |
			IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_NOT_CACHED | IMAGE_SCN_MEM_NOT_PAGED |
			IMAGE_SCN_MEM_SHARED | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE))) {
			fprintf(stderr, "\t[S?] Section Header Seems to be Invalid\n");
		}
		if (pISH->Characteristics & IMAGE_SCN_CNT_CODE)
			printf("\t[S] Section Contains Code\n");
		if (pISH->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA)
			printf("\t[S] Section Contains Initialized Data\n");
		if (pISH->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA)
			printf("\t[S] Section Contains Uninitialized Data\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_DISCARDABLE)
			printf("\t[S] Section Flags that Memory is Discardable\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_NOT_CACHED)
			printf("\t[S] Section Flags to be Discarded\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_NOT_PAGED)
			printf("\t[S] Section Flags that it is Un-Pageable and Not Able to Be Thrown Away or Moved to Disk\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_SHARED)
			printf("\t[S] Section Flags Memory is Shareable\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_EXECUTE)
			printf("\t[S] Section Flags Execution Permissions\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_READ)
			printf("\t[S] Section Flags Read Permission\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_WRITE)
			printf("\t[S] Section Flags Write Permission\n");
	}
	else {
		fprintf(stderr, "[?] Section Header Characteristics Seems to be Empty\n");
	}

	dwSectionTotalSize += pISH->SizeOfRawData;

	return true;
}

bool ImportDirectory(DWORD_PTR pBase, DWORD_PTR pBuffer) {
	PIMAGE_IMPORT_DESCRIPTOR pIID = (PIMAGE_IMPORT_DESCRIPTOR)(pBuffer + pBase);
	DWORD dwCount = 0;

	char szName[64];

	printf("\n!-- DATA DIRECTORY - IMPORTS --!\n");

	do {
		if (!pIID->Characteristics)
			break;

		printf("Import Directory %d\n", dwCount);

		DWORD dwFileOffset = RvaToOffset(pIID->Name, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		printf("[!] Import Directory Name: %s\n", (char *)pBuffer + dwFileOffset);

		strcpy(szName, (char *)pBuffer + dwFileOffset);

		dwFileOffset = RvaToOffset(pIID->OriginalFirstThunk, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		PIMAGE_THUNK_DATA pOriginalFirstThunk = (PIMAGE_THUNK_DATA)(pBuffer + dwFileOffset);

		while (pOriginalFirstThunk->u1.AddressOfData) {
			dwFileOffset = RvaToOffset(pOriginalFirstThunk->u1.AddressOfData, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
			PIMAGE_IMPORT_BY_NAME pIBM = (PIMAGE_IMPORT_BY_NAME)(pBuffer + dwFileOffset);

			if (pOriginalFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
				printf("[!] Library Function Ordinal: %d\n", (pOriginalFirstThunk->u1.Ordinal & 0xFFFF));
			else
				printf("[!] Library Function Name and Possible Ordinal: %s | %d\n", pIBM->Name, pIBM->Hint);

			pOriginalFirstThunk++;

			if (!pOriginalFirstThunk->u1.AddressOfData)
				break;
		}

		if (pIID->TimeDateStamp)
			printf("[!] Import Directory Date Stamp: %d", pIID->TimeDateStamp);

		pIID++;
		dwCount++;
	} while (pIID->Characteristics);

	return true;
}

bool BoundImportDirectory(DWORD pBase, DWORD pBuffer) {
	PIMAGE_BOUND_IMPORT_DESCRIPTOR pBID = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)(pBuffer + pBase);
	DWORD dwCount = 0;

	printf("\n!-- DATA DIRECTORY - BOUND IMPORTS --!\n");

	while (pBID->TimeDateStamp > (DWORD)pBID) {
		printf("Time Date Stamp %d: %s\n", dwCount, (char *)pBID->TimeDateStamp);

		dwCount++;
		pBID++;

		if (!pBID->TimeDateStamp)
			break;
	}

	return true;
}

bool DelayImportDirectory(DWORD pBase, DWORD pBuffer) {
	PIMAGE_DELAYLOAD_DESCRIPTOR pIID = (PIMAGE_DELAYLOAD_DESCRIPTOR)(pBuffer + pBase);
	DWORD dwCount = 0;

	char szName[64];

	printf("\n!-- DATA DIRECTORY - IMPORTS --!\n");

	do {
		if (!pIID->Attributes.AllAttributes)
			break;

		printf("Import Directory %d\n", dwCount);

		DWORD dwFileOffset = RvaToOffset(pIID->DllNameRVA, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		printf("[!] Import Directory Name: %s\n", (char *)pBuffer + dwFileOffset);

		strcpy(szName, (char *)pBuffer + dwFileOffset);

		dwFileOffset = RvaToOffset(pIID->ImportNameTableRVA, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		PIMAGE_THUNK_DATA pOriginalFirstThunk = (PIMAGE_THUNK_DATA)(pBuffer + dwFileOffset);

		while (pOriginalFirstThunk->u1.AddressOfData) {
			dwFileOffset = RvaToOffset(pOriginalFirstThunk->u1.AddressOfData, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
			PIMAGE_IMPORT_BY_NAME pIBM = (PIMAGE_IMPORT_BY_NAME)(pBuffer + dwFileOffset);

			if (pOriginalFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
				printf("[!] Library Function Ordinal: %d\n", (pOriginalFirstThunk->u1.Ordinal & 0xFFFF));
			else
				printf("[!] Library Function Name and Possible Ordinal: %s | %d\n", pIBM->Name, pIBM->Hint);

			pOriginalFirstThunk++;

			if (!pOriginalFirstThunk->u1.AddressOfData)
				break;
		}

		if (pIID->TimeDateStamp)
			printf("[!] Import Directory Date Stamp: %d", pIID->TimeDateStamp);

		pIID++;
		dwCount++;
	} while (pIID->Attributes.AllAttributes);

	return true;
}

bool BaseRelocationDirectory(DWORD pBase, DWORD pBuffer) {
	PIMAGE_BASE_RELOCATION pIBR = (PIMAGE_BASE_RELOCATION)(pBuffer + pBase);
	DWORD dwCount = 0;

	printf("\n!-- DATA DIRECTORY - BASE RELOCATION --!\n");

	while (pIBR->VirtualAddress) {
		if (pIBR->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION)) {
			printf("Base Relocation Block %d\n", dwCount);

			DWORD wAmount = (pIBR->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			PWORD pStart = (PWORD)pIBR + sizeof(IMAGE_BASE_RELOCATION);

			printf("[!] Base Relocation Size of Block: %d\n", pIBR->SizeOfBlock);
			printf("[!] Base Relocation Size of Block(ONLY RELOC DATA): %d\n", wAmount);
			printf("[!] Base Relocation RVA: 0x%X\n", pIBR->VirtualAddress);
			printf("[!] Base Relocation RVA(ONLY RELOC DATA): File: 0x%X or RVA: 0x%X\n", pStart, pIBR->VirtualAddress + sizeof(IMAGE_BASE_RELOCATION));

			dwCount++;
		}

		pIBR = (PIMAGE_BASE_RELOCATION)((LPBYTE)pIBR + pIBR->SizeOfBlock);

		if (!pIBR->VirtualAddress)
			break;
	}

	return true;
}

bool TLSDirectory(DWORD pBase, DWORD pBuffer) {
	MODULEINFO modInfo = { 0 };
	HMODULE hMod = GetModuleHandle(0);

	GetModuleInformation(GetCurrentProcess(), hMod, &modInfo, sizeof(MODULEINFO));

	PIMAGE_TLS_DIRECTORY pITD = (PIMAGE_TLS_DIRECTORY)(pBuffer + pBase);

	printf("\n!-- DATA DIRECTORY - TLS --!\n");
	printf("[!] TLS Directory Start of Raw Data AVA: %d \n", pITD->StartAddressOfRawData);
	printf("[!] TLS Directory End of Raw Data AVA: %d \n", pITD->EndAddressOfRawData);

	DWORD dwCount = 0;

	// AVA to Offset
	DWORD dwRVA = (pITD->AddressOfCallBacks - dwFPos);

	DWORD dwSecCount = 0;
	for (int i = 0; true; i++) {
		if ((DWORD)dwRVA <= dwSectionRVA[i] && (DWORD)dwRVA <= (DWORD)pITD) {
			dwSecCount = (i - 1);
			if ((DWORD)dwRVA == dwSectionRVA[i])
				dwSecCount++;
			break;
		}
	}

	DWORD dwSectionSub = 0;
	for (DWORD i = (dwSecCount - 1); !(dwSectionSizeArray[i]); i--) {
		dwSectionSub++;
	}
	dwSectionSub++;

	DWORD dwSectionForCalc = dwSecCount - dwSectionSub;

	DWORD dwTargetRVA = (dwRVA - dwSectionRVA[dwSectionForCalc]) + dwSectionRVA[dwSectionForCalc];
	DWORD dwTargetPointer = (dwRVA - dwSectionRVA[dwSectionForCalc]) + dwSectionDataPointer[dwSectionForCalc];

	if (dwSectionSub > 1) {
		dwTargetPointer -= (dwRVA - dwSectionRVA[dwSecCount - (dwSectionSub - 1)]);
	}

	DWORD *pITC = (DWORD *)(pBuffer + RvaToOffset(dwTargetRVA, dwRVA, dwTargetPointer));
	for (; (DWORD)*pITC; (DWORD)(pITC)++) {
		printf("[!] TLS Directory Call Back Address %d: 0x%X\n", dwCount, (DWORD)*pITC);
		dwCount++;
	}

	return true;
}

bool ResourceDirectory(DWORD pBase, DWORD pBuffer) {
	PIMAGE_RESOURCE_DIRECTORY pIRD = (PIMAGE_RESOURCE_DIRECTORY)(pBuffer + pBase);

	printf("\n!-- DATA DIRECTORY - RESOURCE --!\n");
	printf("[!] Resource's Number of ID Entries: %d\n", pIRD->NumberOfIdEntries);
	printf("[!] Resource's Number of Named Entries: %d\n", pIRD->NumberOfNamedEntries);

	if (!(pIRD->NumberOfIdEntries) && !(pIRD->NumberOfNamedEntries))
		return false;

	DWORD dwTotalEntries = pIRD->NumberOfIdEntries + pIRD->NumberOfNamedEntries;

	PIMAGE_RESOURCE_DIRECTORY_ENTRY pIRDE = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((PIMAGE_RESOURCE_DIRECTORY)(pIRD + 1));

	for (DWORD i = 0; i < dwTotalEntries; i++) {
		if (pIRDE->NameIsString) {
			PIMAGE_RESOURCE_DIRECTORY_STRING pIRDS = (PIMAGE_RESOURCE_DIRECTORY_STRING)((DWORD)pIRD + (DWORD)pIRDE->NameOffset);

			char szName[64];

			// "strcpy" for possibly NON-NULL Terminated Wide Character Pascal Strings
			DWORD j = 0;
			for (DWORD i = 0; j < pIRDS->Length; i++) {
				if ((char)(pIRDS->NameString[i])) {
					szName[j] = (char)pIRDS->NameString[i];
					j++;
				}
			}

			szName[pIRDS->Length] = 0;

			printf("[!] Resource Directory %d has Name %s ", i, szName);

			if (pIRDE->DataIsDirectory)
				printf("and Directory Offset 0x%X\n", pIRDE->OffsetToDirectory);
			else
				printf("and Data Offset 0x%X\n", pIRDE->OffsetToData);
		}
		else {
			printf("[!] Resource Directory %d has ID 0x%X ", i, pIRDE->NameOffset);

			if (pIRDE->DataIsDirectory)
				printf("and Directory Offset 0x%X\n", pIRDE->OffsetToDirectory);
			else
				printf("and Data Offset 0x%X\n", pIRDE->OffsetToData);
		}
		pIRDE++;
	}

	return true;
}

unsigned long RvaToOffset(DWORD RVAofData, DWORD RVAofSection, DWORD RawData) {
	return RVAofData - RVAofSection + RawData;
}