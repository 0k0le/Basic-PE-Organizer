#define _CRT_SECURE_NO_WARNINGS

#include "defs.h"

DWORD dwSectionDataPointer[24];
DWORD dwSectionRVA[24];
DWORD dwSectionTotalSize = NULL;
int dwTest = 0;

bool SectionHeaderSelector(DWORD_PTR, DWORD, DWORD);
bool ImportDirectory(DWORD, DWORD);
DWORD RvaToOffset(DWORD, DWORD, DWORD);

PIMAGE_DOS_HEADER DosHeader(DWORD_PTR pBuffer) {
	PIMAGE_DOS_HEADER pIDH = NULL;
	PIMAGE_NT_HEADERS pINH = NULL;

	printf("--! ANALYZING DOS HEADER !--\n");

	pIDH = (PIMAGE_DOS_HEADER)pBuffer;

	// Check MZ Exec Signature
	if (pIDH->e_magic != IMAGE_DOS_SIGNATURE) {
		fprintf(stderr, "[?] MZ Value Not Found!\n");
		return 0;
	}

	printf("[!] e_magic value seems intact! e_magic: 0x%X\n", pIDH->e_magic);

	// Check e_lfanew
	pINH = (PIMAGE_NT_HEADERS)(pBuffer + pIDH->e_lfanew);
	if (pINH->FileHeader.Machine)
		printf("[!] e_lfanew value seems to be valid! e_lfanew: 0x%X\n", pIDH->e_lfanew);
	else {
		fprintf(stderr, "[?] e_lfanew value is invalid!\n");
		return 0;
	}

	return pIDH;
}

PIMAGE_NT_HEADERS NtHeaders(DWORD_PTR pBase) {
	PIMAGE_NT_HEADERS pINH = (PIMAGE_NT_HEADERS)pBase;

	printf("\n--! ANALYZING \"NT HEADERS\" STRUCTURE !--\n");

	// Check PE Signature
	if (pINH->Signature != IMAGE_NT_SIGNATURE) {
		fprintf(stderr, "[?] The \"NT HEADERS\" Contains an invalid signature...\n");
		return 0;
	}

	printf("[!] PE Signature Recognized! The 4-Byte ASCII Signature is \"PE\\0\\0\"\n");

	return pINH;
}

PIMAGE_FILE_HEADER FileHeader(DWORD_PTR pBase) {
	PIMAGE_FILE_HEADER pIFH;

	printf("\n--! ANALYZING FILE HEADER !--\n");

	pIFH = (PIMAGE_FILE_HEADER)pBase;

	// Check Assembler Format
	switch (pIFH->Machine) {
	case IMAGE_FILE_MACHINE_I386:
		printf("[!] The FILE HEADER Contains a 32-Bit Machine Signature: PE32 Binary\n");
		break;

	case IMAGE_FILE_MACHINE_AMD64:
		printf("[!] The FILE HEADER Contains a 64-Bit Machine Signature: PE32+ Binary\n");
		break;

	default:
		printf("[!] The FILE HEADER Contains an invalid or esotaric machine signature: 0x%X\n", pIFH->Machine);
		break;
	}

	// Check Epoch Time
	if (!pIFH->TimeDateStamp)
		fprintf(stderr, "[?] The File Header Contains an Invalid Time/Date Stamp...\n");

	printf("[!] The FILE HEADER's Time Since Epoch(sec): %d\n", pIFH->TimeDateStamp);

	// Check Number of Sections
	if (!pIFH->NumberOfSections) {
		fprintf(stderr, "[?] The File Header Contains an Invalid Number Of Sections...\n");
	}
	else {
		printf("[!] The FILE HEADER's Number of Sections: %d\n", pIFH->NumberOfSections);
	}

	// Compare characteristics
	if (pIFH->Characteristics) {
		printf("[SS] The FILE HEADER's Characteristics \\/\n");

		if (pIFH->Characteristics & IMAGE_FILE_32BIT_MACHINE)
			printf("\t[S] IMAGE_FILE_32BIT_MACHINE - 32-Bit Flag\n");
		if (pIFH->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)
			printf("\t[S] IMAGE_FILE_EXECUTABLE_IMAGE - File is Executable\n");
		if (pIFH->Characteristics & IMAGE_FILE_LINE_NUMS_STRIPPED)
			printf("\t[S] IMAGE_FILE_LINE_NUMS_STRIPPED - The Line Numbers Have Been Stripped From File\n");
		if (pIFH->Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE)
			printf("\t[S] IMAGE_FILE LARGE_ADDRESS_AWARE - File Handles > 2gb Addresses\n");
		if (pIFH->Characteristics & IMAGE_FILE_SYSTEM)
			printf("\t[S] IMAGE_FILE_SYSTEM - System Executable\n");
		if (pIFH->Characteristics & IMAGE_FILE_DLL)
			printf("\t[S] IMAGE_FILE_DLL - File is a DLL\n");
		if (!(pIFH->Characteristics & (IMAGE_FILE_32BIT_MACHINE | IMAGE_FILE_EXECUTABLE_IMAGE |
			IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LARGE_ADDRESS_AWARE |
			IMAGE_FILE_SYSTEM | IMAGE_FILE_DLL)))
			fprintf(stderr, "\t[S?] The Characteristics variable contains a value, but does not hold proper values\n");
		if (pIFH->Characteristics & (IMAGE_FILE_DLL | IMAGE_FILE_32BIT_MACHINE | IMAGE_FILE_EXECUTABLE_IMAGE))
			printf("\t[S?] Seems to be a Standard DLL File\n");
	}
	else
		fprintf(stderr, "[?] The File Header Contains an Invalid Characteristics Value...\n");

	// Find Optional Header Size
	if (!pIFH->SizeOfOptionalHeader) {
		fprintf(stderr, "[?] The File Header Contains an Invalid Optional Header Size...\n");
	}
	else {
		printf("[!] The FILE HEADER's size of optional header variable: 0x%X\n", pIFH->SizeOfOptionalHeader);
	}
	
	return pIFH;
}

PIMAGE_OPTIONAL_HEADER OptionalHeader(DWORD_PTR pBase, DWORD_PTR pBuffer, DWORD dwFileSize) {
	PIMAGE_OPTIONAL_HEADER pIOH = (PIMAGE_OPTIONAL_HEADER)pBase;
	DWORD dwFileOffset = NULL;

	printf("\n--! OPTIONAL HEADER !--\n");

	// Testing Magic Number
	if (pIOH->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC && pIOH->Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		fprintf(stderr, "[?] The Optional Header's Magic Value Does Not Match 32 or 64 Bit Definitions\n");
	} else if (pIOH->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
		printf("[!] The Optional Header's Magic Value Matches a 32 Bit Signature\n");
	} else if (pIOH->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		printf("[!] The Optional Header's Magic Value Matches a 64 Bit Signature\n");
	}

	if (!pIOH->AddressOfEntryPoint) {
		fprintf(stderr, "[?] The Optional Header's Entry Point RVA is invalid\n");
	}

	printf("[!] The Optional Header's Entry Point RVA: 0x%X\n", pIOH->AddressOfEntryPoint);

	if(!pIOH->SizeOfImage) {
		fprintf(stderr, "[?] The Optional Header's Size of Image Variable is Invalid");
	}

	printf("[!] The Optional Header's Size of Image vs File Size: %d/%d Bytes\n", pIOH->SizeOfImage, dwFileSize);
	
	if (!pIOH->SectionAlignment || !pIOH->FileAlignment) {
		fprintf(stderr, "[?] The Optional Header's Section Alignment or File Alignment is Invalid\n");
	}

	printf("[!] The Optional Header's Section Alignment(Buffer) and File Alignment(Section Chunks): 0x%x & 0x%x \n", pIOH->SectionAlignment, pIOH->FileAlignment);

	if (!pIOH->ImageBase) {
		fprintf(stderr, "[?] The Optional Header's Image Base is Invalid\n");
	}

	printf("[!] The Optional Header's Image Base: 0x%x\n", pIOH->ImageBase);

	// Dll Characteristics
	if (pIOH->DllCharacteristics) {
		printf("[SS] The Optional Header's DLL Characteristics \\/\n");

		if (pIOH->DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)
			printf("\t[S] IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE - The DLL Can Move\n");
		if (pIOH->DllCharacteristics & IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY)
			printf("\t[S] IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY - Force Signed HASH Check\n");
		if (pIOH->DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
			printf("\t[S] IMAGE_DLLCHARACTERISTICS_NX_COMPAT - Compatible with DEP\n");
		if (pIOH->DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_SEH)
			printf("\t[S] IMAGE_DLLCHARACTERISTICS_NO_SEH - No Structered Exception Handling\n");
		if (!(pIOH->DllCharacteristics &
			(IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE | IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY |
				IMAGE_DLLCHARACTERISTICS_NX_COMPAT | IMAGE_DLLCHARACTERISTICS_NO_SEH)))
			fprintf(stderr, "\t[S?] This PE File Lacks Common Security Characteristics (ex: DEP, ASLR, SEH)\n");
	} else {
		fprintf(stderr, "[?] The Optional Header's DLL Characteristics Variable is NULL\n");
	}

	for (int i = 0; true; i++) {
		if ((DWORD)pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress < dwSectionRVA[i]) {
			dwTest = (i - 1);
			break;
		}
	}

	if (dwTest > -1) {
		dwFileOffset = RvaToOffset(pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		printf("[!] Import Directory File Offset: %d | 0x%X\n", dwFileOffset, dwFileOffset);
		printf("[!] Import Directory Virtual Address %d | 0x%X\n", pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
			pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

		if (!ImportDirectory(dwFileOffset, pBuffer)) {
			fprintf(stderr, "[?] The Optional Header's Import Directory is Invalid\n");
		}

	}
	else {
		printf("[?] Failed To Find Import Directory...\n");
	}

	return pIOH;
}

PIMAGE_SECTION_HEADER SectionHeader(DWORD_PTR pBase, DWORD dwSections, DWORD dwFileAlignment) {
	PIMAGE_SECTION_HEADER pISH = (PIMAGE_SECTION_HEADER)pBase;

	printf("\n--! SECTION HEADER !--\n");

	for (DWORD dwCount = 0; dwCount < dwSections; dwCount++) {
		DWORD_PTR pNewSection = (DWORD_PTR)pISH;

		if (!SectionHeaderSelector(pNewSection, dwCount, dwFileAlignment)) {
			fprintf(stderr, "[?] Failed to Read Section %d\n", dwCount);
			return 0;
		}

		pISH++;
	}

	return pISH;
}

/*PRIVATE FUNCTIONS*/

bool SectionHeaderSelector(DWORD_PTR pBase, DWORD dwCount, DWORD dwFileAlignment) {
	PIMAGE_SECTION_HEADER pISH = (PIMAGE_SECTION_HEADER)pBase;

	char szName[9];

	printf("SECTION %d\n", dwCount);

	// "strcpy" for possibly NON-NULL Terminated Strings
	for (DWORD i = 0; i < 9; i++) {
		if (!((BYTE)pISH->Name[i])) {
			szName[i] = 0;
			break;
		}

		szName[i] = (char)pISH->Name[i];
	}

	if (strlen(szName) >= 9)
		szName[8] = 0;

	if (!((int)szName[0])) {
		fprintf(stderr, "[?] The Section Header's Name is Invalid or Miss Read\n");
		return false;
	}

	printf("[!] The Section Header's Name is: %s\n", szName);

	if (!pISH->Misc.VirtualSize) {
		fprintf(stderr, "[?] Section Header Misc.VirtualSize is Invalid\n");
	}

	printf("[!] Section Header Misc.VirtualSize: 0x%X | %d\n", pISH->Misc.VirtualSize, pISH->Misc.VirtualSize);

	if (!pISH->SizeOfRawData) {
		fprintf(stderr, "[?] Section Header Size of Raw Data is Invalid for an Executable\n");
	}

	if (pISH->Misc.VirtualSize < dwFileAlignment) {
		printf("[?] Section Header Misc.VirtualSize is Smaller than the Required Length of %d\n", dwFileAlignment);
	}

	printf("[!] Section Header Size of Raw Data: 0x%X | %d\n", pISH->SizeOfRawData, pISH->SizeOfRawData);

	if (pISH->Misc.VirtualSize > pISH->SizeOfRawData) {
		printf("[?] Section Header Size of Raw Data is Less than the Virtual Size\n");
	}

	if (!pISH->PointerToRawData) {
		fprintf(stderr, "[?] Section Header Pointer to Raw Data is Invalid for an Executable\n");
	}

	printf("[!] Section Header Pointer to Raw Data: 0x%X\n", pISH->PointerToRawData);

	printf("[!] Section Header Virtual Address: %d | 0x%X\n", pISH->VirtualAddress, pISH->VirtualAddress);

	dwSectionDataPointer[dwCount] = pISH->PointerToRawData;
	dwSectionRVA[dwCount] = pISH->VirtualAddress;

	if (pISH->Characteristics) {
		printf("[SS] Section Header's Characteristics\\/\n");

		if (!(pISH->Characteristics & (IMAGE_SCN_CNT_CODE | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_UNINITIALIZED_DATA |
			IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_NOT_CACHED | IMAGE_SCN_MEM_NOT_PAGED |
			IMAGE_SCN_MEM_SHARED | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE))) {
			fprintf(stderr, "\t[S?] Section Header Seems to be Invalid\n");
		}
		if (pISH->Characteristics & IMAGE_SCN_CNT_CODE)
			printf("\t[S] Section Contains Code\n");
		if (pISH->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA)
			printf("\t[S] Section Contains Initialized Data\n");
		if (pISH->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA)
			printf("\t[S] Section Contains Uninitialized Data\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_DISCARDABLE)
			printf("\t[S] Section Flags that Memory is Discardable\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_NOT_CACHED)
			printf("\t[S] Section Flags to be Discarded\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_NOT_PAGED)
			printf("\t[S] Section Flags that it is Un-Pageable and Not Able to Be Thrown Away or Moved to Disk\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_SHARED)
			printf("\t[S] Section Flags Memory is Shareable\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_EXECUTE)
			printf("\t[S] Section Flags Execution Permissions\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_READ)
			printf("\t[S] Section Flags Read Permission\n");
		if (pISH->Characteristics & IMAGE_SCN_MEM_WRITE)
			printf("\t[S] Section Flags Write Permission\n");
	} else {
		fprintf(stderr, "[?] Section Header Characteristics Seems to be Empty\n");
	}

	dwSectionTotalSize += pISH->SizeOfRawData;

	return true;
}

bool ImportDirectory(DWORD_PTR pBase, DWORD_PTR pBuffer) {
	PIMAGE_IMPORT_DESCRIPTOR pIID = (PIMAGE_IMPORT_DESCRIPTOR)(pBuffer + pBase);
	DWORD dwCount = 0;

	printf("\n!-- DATA DIRECTORY --!\n");

	do {
		if (!pIID->Characteristics)
			break;

		printf("Import Directory %d\n", dwCount);

		DWORD dwFileOffset = RvaToOffset(pIID->Name, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		printf("[!] Import Directory Name: %s\n", (char *)pBuffer + dwFileOffset);

		dwFileOffset = RvaToOffset(pIID->OriginalFirstThunk, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
		PIMAGE_THUNK_DATA pOriginalFirstThunk = (PIMAGE_THUNK_DATA)(pBuffer + dwFileOffset);

		while (pOriginalFirstThunk->u1.AddressOfData) {

			dwFileOffset = RvaToOffset(pOriginalFirstThunk->u1.AddressOfData, dwSectionRVA[dwTest], dwSectionDataPointer[dwTest]);
			PIMAGE_IMPORT_BY_NAME pIBM = (PIMAGE_IMPORT_BY_NAME)(pBuffer + dwFileOffset);

			printf("[!] Library Function Name and Possible Ordinal: %s | %d\n", pIBM->Name, pIBM->Hint);

			pOriginalFirstThunk++;

			if (!pOriginalFirstThunk->u1.AddressOfData)
				break;
		}

		if (pIID->TimeDateStamp)
			printf("[!] Import Directory Date Stamp: %d", pIID->TimeDateStamp);

		pIID++;
		dwCount++;
	} while (pIID->Characteristics);

	return true;
}

DWORD RvaToOffset(DWORD RVAofData, DWORD RVAofSection, DWORD RawData) {
	return RVAofData - RVAofSection + RawData;
}